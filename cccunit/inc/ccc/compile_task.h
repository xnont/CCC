#ifndef __COMPILE_TASK_H__
#define __COMPILE_TASK_H__

#include "ccc/config.h"
#include "ccc/dependency.h"

#include <memory>
#include <source_location>
#include <string>
#include <vector>

namespace ccc {

/* The base class of all compile tasks.  */
class compile_task : public ccc::config_manager {
  public:
    /**
     * @brief Construct a new compile task object.
     *
     * @param name The name of the task.
     * @param description The description of the task.
     * @param loc The location of the task.
     */
    compile_task(std::string name, std::string description,
                 std::source_location loc);

    /**
     * @brief Construct a new compile task object by copying another compile
     *        task object.
     *
     * @param other The compile task object to be copied.
     */
    compile_task(const compile_task& other)
        : config_manager(other.config), name(other.name),
          output_path(other.output_path), obj_path(other.obj_path),
          source_files(other.source_files), obj_files(other.obj_files),
          lib_files(other.lib_files), dependencies(other.dependencies),
          loc(other.loc) {};

    /**
     * @brief The subclass of compile_task must implement a clone constructor.
     *
     * @return compile_task* The clone of the compile_task object.
     */
    virtual compile_task* clone() const = 0;

    /* The name of the task.(The path of the final product is output_path +
     * name) */
    std::string name;

    /* The output path of the task.(The path of the final product is output_path
     * + name) */
    std::string output_path = "./build/";

    /* The path for storing intermediate products. */
    std::string obj_path = "./build/obj/";

    /* The source files of the task. */
    std::vector<std::string> source_files;

    /* The intermediate products of the task.(Automatically generated by the
     * compile_task class based on the source files, or can be added by
     * oneself.) */
    std::vector<std::string> obj_files;

    /* This variable stores the name of the library required for this task. */
    std::vector<std::string> lib_files;

    /* The dependencies of the task. */
    std::vector<
        std::pair<std::shared_ptr<ccc::compile_task>, dependency_description>>
        dependencies;

    /* The location of the project */
    std::source_location loc;

    /**
     * @brief Add a dependency to the compile task.
     *
     * @param dep The dependency of the task.
     * @param is_transmit Whether add it directly to the compile task.
     * @param is_compile Whether to actively compile dependencies, if
     *                   dependencies do not exist.
     */
    void add_dependency(const ccc::compile_task* dep, bool is_transmit,
                        bool is_compile = false) {
        dependencies.push_back(std::make_pair(
            std::shared_ptr<compile_task>(dep->clone()),
            ccc::dependency_description(is_transmit, is_compile)));
    }

    /**
     * @brief Compile all source files in source_files.
     *
     * @param project_cfg The config of the father project.
     * @param path The path indicating the compilation order relationship.
     */
    virtual void compile(const ccc::config& project_cfg,
                         std::vector<std::string>& path) final;

    /**
     * @brief Set the toolchain object.
     *
     * @param project_cfg The config of the father project.
     */
    virtual void set_toolchain(const ccc::config& project_cfg) = 0;

    /**
     * @brief The subclass needs to implement this function, and the linking
     *        operation of the subclass needs to be implemented in this
     *        function.
     *
     * @param project_cfg The config of the father project.
     */
    virtual void link(const ccc::config& project_cfg) = 0;

    /**
     * @brief The subclass needs to implement this function. When the parent
     * task wants to add a subtask directly to itself, this method will be
     * called.
     *
     * @param super The parent task.
     */
    virtual void transmit(ccc::compile_task& super) = 0;

    /* The convenient utility functions provided by ccc. */

    /**
     * @brief Add file_path to the source_files variable.
     *
     * @param file_path The file_path need to be added to the source_files
     *        variable.
     */
    virtual void add_source_file(const std::string& file_path) final;

    /**
     * @brief Add these file_paths to the source_files variable.
     *
     * @param file_paths The file_paths need to be added to the source_files
     *        variable.
     */
    virtual void add_source_files(
        const std::initializer_list<std::string>& file_paths) final;

    /**
     * @brief Add all files in the dir_paths which have the suffix in suffixs to
     *        the the source_files variable.(Default recursion into subfolders.)
     *
     * @param dir_paths The dir_paths which have the files need to be added to.
     * @param suffixs The suffixs of the files need to be added to the
     *        source_files variable.
     * @param recursive Decide whether to recursively enter subfolders.
     */
    virtual void
    add_source_files(const std::initializer_list<std::string>& dir_paths,
                     const std::initializer_list<std::string>& suffixs,
                     bool recursive = true) final;

    /**
     * @brief Add all files in the dir_paths which satisfy the judge function to
     *        the the source_files variable.(Default recursion into subfolders.)
     *
     * @param dir_paths The dir_paths which have the files need to be added to.
     * @param judge The function which decides whether to add the file.
     * @param recursive Decide whether to recursively enter subfolders.
     */
    virtual void
    add_source_files(const std::initializer_list<std::string>& dir_paths,
                     auto judge(const std::string&)->bool,
                     bool recursive = true) final;

    /**
     * @brief Remove file_path from the source_files variable.
     *
     * @param file_path The file_path need to be removed from the source_files
     *        variable.
     */
    virtual void remove_source_file(const std::string& file_path) final;

    /**
     * @brief Remove these file_paths from the source_files variable.
     *
     * @param file_paths The file_paths need to be removed from the source_files
     *        variable.
     */
    virtual void remove_source_files(
        const std::initializer_list<std::string>& file_paths) final;

    /**
     * @brief Remove all files in the source_files variable which satisfy the
     *        judge function.
     *
     * @param judge The function which decides whether to remove the file.
     * @return int The number of files removed.
     */
    virtual int remove_source_files(auto judge(const std::string&)->bool) final;

    /**
     * @brief Find whether the file_path is in the source_files variable.
     *
     * @param file_path The file_path need to be found in the source_files.
     * @return true The file_path is in the source_files.
     * @return false The file_path is not in the source_files.
     */
    virtual bool find_source_file(const std::string& file_path) final;

  private:
    /**
     * @brief Compile a source file.
     *
     * @param project_cfg The config of the father project.
     * @param source_file The source file need to be compiled.
     */
    void compile_source_file(const ccc::config& project_cfg,
                             const std::string& source_file);
};
} // namespace ccc

#endif